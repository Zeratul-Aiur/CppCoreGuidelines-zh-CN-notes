# 笔记

## P.1: 在代码中直接表达你的想法

- 用恰当的程序库来表达设计意图，远比直接使用语言实现好得多。任何程序员应当熟知标准库的基本知识，并在适当的时候加以利用。例如多使用 STL 算法，而非显式循环。
- 一个成员函数是否以`const`修饰，不在于这个成员函数到底是否会修改自己的成员，而在于**可变性**。例如标准库中往往会提供两个版本的接口：

    ```cpp
    constexpr reference operator[]( size_type pos );
    constexpr const_reference operator[]( size_type pos ) const;
    ```

  - 这两个函数都不会修改自己存储的对象，但是它们的返回类型不同。

## P.10: 不可变数据优先于可变数据

- 如果它可以是常量，那就把它设置为常量。

## P.13: 适当采用支持程序库

- 使用设计良好，文档全名，并且有良好支持的程序库可以节省时间和工作量。程序库的成本可以由大量的用户所分担。

## I.2: 避免非 const 全局变量

- 全局变量会在函数中注入隐藏的依赖，而该依赖并不是接口的一部分。例如下面的纯函数例子，编译器可以将之前的结果存储到缓存中以进行复用。

    ```cpp
    int add(int a,int b){
        return a + b;
    }

    int main(){
        int c = add(1, 2) + add(1, 2) + add(1, 3);
    }
    ```

- 除此以外，还有别的负担：
  - 可测试性：只能进行系统测试，不能进行单元测试。
  - 重构：无法孤立地对代码进行推理，重构它会相当具有挑战性。
  - 优化：因为存在隐藏的依赖，你无法轻易重新安排函数调用或者在不同线程上进行函数调用。缓存之前函数调用的结果也极为危险。
  - 并发：共享而可变的对象很容易产生数据竞争。

## I.27: 对于稳定的程序库 ABI，考虑使用 Pimpl 手法

- 由于私有数据成员参与类的内存布局，私有成员函数参与重载决议，**对这些实现细节的改动都要求使用了该类的所有用户全部重新编译**。而持有指向实现的指针的非多态的接口类，则可以将类的用户从其实现的改变隔离开来，而代价是一层间接。

## F.4: 如果函数可能必须在编译期进行求值，就将其声明为 constexpr

- `constexpr`函数是可能在编译期运行的函数。当你在常量表达式中调用`constexpr`函数时，或者当你用`constexpr`变量来获取`constexpr`函数的结果时，它会在编译期运行。`constexpr`函数是隐含内联的。

## F.5: 如果函数非常小，并且是时间敏感的，就将其声明为 inline

- 在类中所定义的成员函数默认是内联的。
- 函数模板一般都定义在头文件中，因此是内联的。

## F.6: 如果函数必然不会抛出异常，就将其声明为 noexcept

- 即使你的函数可以抛出异常，标记为`noexcept`往往也合理。意味着，**我不在乎异常。其原因可能是，你无法对异常做出反应**。例如内存耗尽时崩溃。
- 以下类型的函数永远不该抛出异常：析构函数，`swap`函数，移动构造函数，移动赋值函数和默认构造函数。

## F.16: 对于“输入（in）”参数，把复制操作廉价的类型按值进行传递，把其他类型按 const 引用进行传递

- 如果拷贝开销不低，那就通过`const`引用来传入。
- 书中的经验法则是：
  - 如果`sizeof(par) <= 2 * sizeof(void *)`，那么按值传递。
  - 如果`sizeof(par) > 2 * sizeof(void *)`，那么按`const`引用传递参数。

## F.20: 对于“输出（out）”值，采用返回值优先于输出参数

- 也许你认为值拷贝的开销巨大，这**既对也不对**。原因在于编译器会应用**返回值优化**。

## F.21: 要返回多个“输出”值，优先返回结构体

- C++17 中的结构化绑定使得返回多个值变得非常优雅。

## F.45: 不要返回 T&&

- 右值引用同样也是引用。同样也会因为引用了局部对象，产生悬垂引用。

## C.2: 当类具有不变式时使用 class；当数据成员可以独立进行变动时使用 struct

- 可读性；易理解性。
- 这是一种很有用的惯例。

## C.21: 如果定义或者 =delete 了任何复制、移动或析构函数，请定义或者 =delete 它们全部

## C.47: 按成员声明的顺序对数据成员进行定义和初始化

- 尽量避免混淆和错误。初始化的发生顺序只与成员声明的顺序有关，和成员初始化式的顺序无关。

  ```cpp
  class Foo {
    int m1;
    int m2;
  public:
    Foo(int x) : m2(x), m1(++x) {} // 不好：有误导性的初始化式顺序
  };

  Foo x(1); // x.m1 == x.m2 == 2
  ```

## C.131: 避免无价值的取值和设值函数

- 不如直接将数据成员变成`public`。更进一步，应当考虑把这个类变为`struct`。
